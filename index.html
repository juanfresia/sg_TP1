<html>

<head lang="en">
	<meta charset="UTF-8">
	<title>Prueba de sg</title>
	
	<style>
		body{ background-color: #00E676; }
		canvas{ background-color: #C51162; }
		textarea{ background-color: black; foreground-color: white;}
	</style>
	
	<script type="text/javascript" src="gl-matrix.js"></script>
	<script type="text/javascript" src="dat.gui.js"></script>
	<script type="text/javascript" src="scene.js"></script>
	<script type="text/javascript" src="input_handler.js"></script>
	
	<script type="text/javascript" src="primitives\grid.js"></script>
	<script type="text/javascript" src="primitives\surfaces.js"></script>
	<script type="text/javascript" src="primitives\segment_curve.js"></script>
	<script type="text/javascript" src="primitives\bspline.js"></script>
	<script type="text/javascript" src="primitives\terna.js"></script>
	<script type="text/javascript" src="primitives\circumference.js"></script>
	<script type="text/javascript" src="objects\tower_base.js"></script>
	<script type="text/javascript" src="objects\ship.js"></script>
	<script type="text/javascript" src="objects\water.js"></script>
	<script type="text/javascript" src="objects\tensor.js"></script>
	<script type="text/javascript" src="objects\terrain.js"></script>
	<script type="text/javascript" src="objects\tower.js"></script>
	<script type="text/javascript" src="objects\bridge_base.js"></script>
	<script type="text/javascript" src="objects\bridge_side.js"></script>
	<script type="text/javascript" src="objects\bridge.js"></script>
	
	<!-- Shader de vértices sin texturas -->
	<script id="shader-vs" type="x-shader/x-vertex">
		// Atributos del vértice
		attribute vec3 aVertexPosition;
		attribute vec3 aVertexNormal;
		attribute vec3 aVertexColor;
		
		// Matrices de Vista, Modelo, Proyección y Normales
		uniform mat4 uVMatrix;
		uniform mat4 uMMatrix;
		uniform mat4 uPMatrix;
		uniform mat3 uNMatrix;
		
		// Decide si se usa o no la iluminación
		uniform bool uUseLighting;
		
		// Parámetros de iluminación
		uniform vec3 uAmbientColor;
		uniform vec3 uLightPosition;
		uniform vec3 uDirectionalColor;
		varying highp vec4 vColor;
		
		varying vec3 vVertexColor;
		varying vec3 vLightWeighting;

		void main(void) {
		
		
			// Consigo la posición proyectada del punto multiplicando por todas las matrices.
			vec4 model_world_pos = uMMatrix * vec4(aVertexPosition, 1.0);
			vec4 model_view_pos = uVMatrix * model_world_pos;
			gl_Position = uPMatrix * model_view_pos;
			
			// El color a utilizar es el mismo del vértice (no hay texturas).
			vVertexColor = aVertexColor;
			
			// ILUMINACIÓN
			
			// Calculo la posición relativa de la fuente de luz dirigida respecto al vértice y normalizo
			
			
			vec4 new_light_position = vec4(uLightPosition, 1.0);
			new_light_position = uVMatrix * new_light_position;
						
			vec3 light_dir = vec3(uLightPosition) - vec3(model_world_pos);
			light_dir = normalize(light_dir);
			
			if (!uUseLighting) {
				vLightWeighting = vec3(1.0, 1.0, 1.0);
			} else {
				vec3 transformedNormal = normalize(uNMatrix * aVertexNormal);
				highp float directionalLightWeighting = max(dot(transformedNormal, light_dir), 0.0);
				vLightWeighting = uAmbientColor + uDirectionalColor * directionalLightWeighting;
			}
		}
	
	</script>

	<!-- Shader de fragmentos sin texturas -->
	<script id="shader-fs" type="x-shader/x-fragment">
		precision mediump float;

		varying vec3 vVertexColor;
		varying vec3 vLightWeighting;

		uniform sampler2D uSampler;

		void main(void) {
			gl_FragColor = vec4(vVertexColor.rgb * vLightWeighting, 1.0);
		}
	</script>
	
	
	
	<!-- Shader de vértices para el agua -->
	<script id="water-vs" type="x-shader/x-vertex">
		// Atributos del vértice
		attribute vec3 aVertexPosition;
		attribute vec3 aVertexNormal;
		attribute vec3 aVertexColor;
		
		// Matrices de Vista, Modelo, Proyección y Normales
		uniform mat4 uVMatrix;
		uniform mat4 uMMatrix;
		uniform mat4 uPMatrix;
		uniform mat3 uNMatrix;
		
		// Decide si se usa o no la iluminación
		uniform bool uUseLighting;
		
		// Parámetros de iluminación
		uniform vec3 uAmbientColor;
		uniform vec3 uLightPosition;
		uniform vec3 uDirectionalColor;				
		varying highp vec4 vColor;
		uniform highp float uTime;
		
		varying vec3 vVertexColor;
		varying vec3 vLightWeighting;
		
		void main(void) {
			
			float kx = 0.1;
			float kz = 0.1;
			float wx = 0.5;
			float wz = 2.0;
			float amp = 1.0;
			
			// Consigo la posición proyectada del punto multiplicando por todas las matrices.
			vec4 model_world_pos = uMMatrix * vec4(aVertexPosition, 1.0);
			vec3 normal = vec3(0.0, 1.0, 0.0);
			
			model_world_pos[1] = model_world_pos[1] + amp * sin(model_world_pos[2]* kz + uTime * wz) * sin(model_world_pos[0]* kx + uTime * wx);
			normal[0] = amp * sin(model_world_pos[2]* kz + uTime * wz) * kx * cos(model_world_pos[0]* kx + uTime * wx);
			normal[2] = amp * sin(model_world_pos[2]* kz + uTime * wz) * kz * cos(model_world_pos[2]* kz + uTime * wz);
			normal[1] = 1.0;
			
			
			vec4 model_view_pos = uVMatrix * model_world_pos;
			gl_Position = uPMatrix * model_view_pos;
			
			// El color a utilizar es el mismo del vértice (no hay texturas).
			vVertexColor = aVertexColor;
			
			// ILUMINACIÓN
			
			// Calculo la posición relativa de la fuente de luz dirigida respecto al vértice y normalizo
			
			
			vec4 new_light_position = vec4(uLightPosition, 1.0);
			new_light_position = uVMatrix * new_light_position;
			
			
			
			vec3 light_dir = vec3(uLightPosition) - vec3(model_world_pos);
			light_dir = normalize(light_dir);
			
			if (!uUseLighting) {
				vLightWeighting = vec3(1.0, 1.0, 1.0);
			} else {
				vec3 transformedNormal = normalize(normal);
				highp float directionalLightWeighting = max(dot(transformedNormal, light_dir), 0.0);
				vLightWeighting = uAmbientColor + uDirectionalColor * directionalLightWeighting;
			}
		}
	
	</script>	
		
	<!-- El script posta -->
	<script>
	
	var canvas = null;
	var gl = null;
	var glShaderColor;
	var glShaderWater;
	

	
	 // SHADERS FUNCTION
	function getShader(gl, id) {
		var shaderScript, src, currentChild, shader;

		// Obtenemos el elemento <script> que contiene el código fuente del shader.
		shaderScript = document.getElementById(id);
		if (!shaderScript) {
			return null;
		}

		// Extraemos el contenido de texto del <script>.
		src = "";
		currentChild = shaderScript.firstChild;
		while(currentChild) {
			if (currentChild.nodeType == currentChild.TEXT_NODE) {
				src += currentChild.textContent;
			}
			currentChild = currentChild.nextSibling;
		}

		// Creamos un shader WebGL según el atributo type del <script>.
		if (shaderScript.type == "x-shader/x-fragment") {
			shader = gl.createShader(gl.FRAGMENT_SHADER);
		} else if (shaderScript.type == "x-shader/x-vertex") {
			shader = gl.createShader(gl.VERTEX_SHADER);
		} else {
			return null;
		}

		// Le decimos a WebGL que vamos a usar el texto como fuente para el shader.
		gl.shaderSource(shader, src);

		// Compilamos el shader.
		gl.compileShader(shader);  
		  
		// Chequeamos y reportamos si hubo algún error.
		if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {  
			alert("Error compilando los shaders: " + 
			gl.getShaderInfoLog(shader));  
			return null;  
		}
		  
		return shader;
	}
	
	// Carga el canvas y obtiene el rendering context
	function initWebGL() {
		canvas = document.getElementById("my_canvas");
		try {
			gl = canvas.getContext("webgl");
		} catch (e) {
			console.log("Error cargando WebGL");
		}
	}
	
	// Configuración del canvas
	function setupWebGL() {
		gl.clearColor(0.77, 0.07, 0.243, 1.0);
		
		// Habilitando y configurando cómo tratar el buffer de profundidad
		gl.enable(gl.DEPTH_TEST);
		gl.depthFunc(gl.LEQUAL);
		
		gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);
		
		// Configurando el viewport
		gl.viewport(0, 0, canvas.width, canvas.height);
		
	}
			
	function initShaders() {
		// Creo el programa con los shaders para objetos coloreados
		var fragmentShader = getShader(gl, "shader-fs");
		var vertexShader = getShader(gl, "shader-vs");
		var waterShader = getShader(gl, "water-vs");
		
		glShaderColor = gl.createProgram();
		
		gl.attachShader(glShaderColor, vertexShader);
		gl.attachShader(glShaderColor, fragmentShader);
		
		gl.linkProgram(glShaderColor);
		
		if (!gl.getProgramParameter(glShaderColor, gl.LINK_STATUS)) {
			alert("Error cargando los shaders.  " + gl.getProgramInfoLog(glShaderColor));
			return null;
		}		
		// Punteros a los atributos del shader
		glShaderColor.aVertexPosition = gl.getAttribLocation(glShaderColor, "aVertexPosition");
		gl.enableVertexAttribArray(glShaderColor.aVertexPosition);
		
		glShaderColor.aVertexNormal = gl.getAttribLocation(glShaderColor, "aVertexNormal");
		gl.enableVertexAttribArray(glShaderColor.aVertexNormal);
		
		glShaderColor.aVertexColor = gl.getAttribLocation(glShaderColor, "aVertexColor");
		gl.enableVertexAttribArray(glShaderColor.aVertexColor);
		
		// Punteros a las matrices y parámetros uniform
		glShaderColor.uVMatrix = gl.getUniformLocation(glShaderColor, "uVMatrix");
		glShaderColor.uMMatrix = gl.getUniformLocation(glShaderColor, "uMMatrix");
		glShaderColor.uPMatrix = gl.getUniformLocation(glShaderColor, "uPMatrix");
		glShaderColor.uNMatrix = gl.getUniformLocation(glShaderColor, "uNMatrix");
			// Parámetros de iluminación
		glShaderColor.uUseLighting = gl.getUniformLocation(glShaderColor, "uUseLighting");
		glShaderColor.uAmbientColor = gl.getUniformLocation(glShaderColor, "uAmbientColor");
		glShaderColor.uLightPosition = gl.getUniformLocation(glShaderColor, "uLightPosition");
		glShaderColor.uDirectionalColor = gl.getUniformLocation(glShaderColor, "uDirectionalColor");
		
		glShaderWater = gl.createProgram();
		gl.attachShader(glShaderWater, waterShader);
		gl.attachShader(glShaderWater, fragmentShader);
		
		gl.linkProgram(glShaderWater);
		
		if (!gl.getProgramParameter(glShaderWater, gl.LINK_STATUS)) {
			alert("Error cargando los shaders.  " + gl.getProgramInfoLog(glShaderWater));
			return null;
		}		
		// Punteros a los atributos del shader
		glShaderWater.aVertexPosition = gl.getAttribLocation(glShaderWater, "aVertexPosition");
		gl.enableVertexAttribArray(glShaderWater.aVertexPosition);
		
		glShaderWater.aVertexNormal = gl.getAttribLocation(glShaderWater, "aVertexNormal");
		gl.enableVertexAttribArray(glShaderWater.aVertexNormal);
		
		glShaderWater.aVertexColor = gl.getAttribLocation(glShaderWater, "aVertexColor");
		gl.enableVertexAttribArray(glShaderWater.aVertexColor);
		
		// Punteros a las matrices y parámetros uniform
		glShaderWater.uVMatrix = gl.getUniformLocation(glShaderWater, "uVMatrix");
		glShaderWater.uMMatrix = gl.getUniformLocation(glShaderWater, "uMMatrix");
		glShaderWater.uPMatrix = gl.getUniformLocation(glShaderWater, "uPMatrix");
		glShaderWater.uNMatrix = gl.getUniformLocation(glShaderWater, "uNMatrix");
			// Parámetros de iluminación
		glShaderWater.uUseLighting = gl.getUniformLocation(glShaderWater, "uUseLighting");
		glShaderWater.uAmbientColor = gl.getUniformLocation(glShaderWater, "uAmbientColor");
		glShaderWater.uLightPosition = gl.getUniformLocation(glShaderWater, "uLightPosition");
		glShaderWater.uDirectionalColor = gl.getUniformLocation(glShaderWater, "uDirectionalColor");
		glShaderWater.uTime = gl.getUniformLocation(glShaderWater, "uTime");
										
		gl.useProgram(glShaderColor);
	}
	
	////////
	var time = 0;
	var pMatrix = mat4.create();
	var my_scene = null;
	var handler = null;
	function drawScene() {
		// Esto garantiza que se llame continuamente al drawScene
		requestAnimationFrame(drawScene);
		
		gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
		
		// Preparamos una matriz de perspectiva. (FOV, aspectRatio, z_front y z_back).
		mat4.perspective(pMatrix, 45, 1280.0/768.0, 0.1, 1000.0);
		
		gl.uniformMatrix4fv(glShaderColor.uPMatrix, false, pMatrix);
		
		gl.useProgram(glShaderWater);
		gl.uniform1f(glShaderWater.uTime, time);
		gl.uniformMatrix4fv(glShaderWater.uPMatrix, false, pMatrix);
		gl.useProgram(glShaderColor);
		
		my_scene.draw(time, handler.get_view_matrix());
		time += 0.02;
	}
		
	function loadHandler() {
		handler = new InputHandler();
		handler.setup_handlers();
	}	
	
	function loadScene() {
		my_scene = new Scene();
		my_scene.init();
	}	
	
	var params = {
		// Terreno
		ter_ancho:260,
		ter_alto:10,
		rio_ancho:120,
		agua_alto:8,
		puente_pos:0.5,
	
		// Torres
		ancho_corte:0.2,
		prof_corte:0.7,
		reduccion:0.8,
		
		// Puente
		puente_ph2:2,
		puente_ph3:20,
		puente_num_torres:3,
		puente_largo:150,
		puente_cur:0.8,
		puente_sep:2.5,
		puente_ancho:9.0,
		puente_nivel:true,
		
	
		line_strip:false,
		debug_mode:true,
		reiniciar:loadScene
	};
	
	function setupGUI() {
	
		var gui = new dat.GUI();
		
		var group_terrain = gui.addFolder('Terreno');
		group_terrain.add(params, 'ter_ancho', 200.0, 500.0).name('Tamaño del mapa').step(10);
		group_terrain.add(params, 'ter_alto', 2.0, 20.0).name('Elevacion del terreno').step(1);
		group_terrain.add(params, 'rio_ancho', 10.0, 200.0).name('Ancho del rio').step(1);
		group_terrain.add(params, 'agua_alto', 1.0, 8.0).name('Altura del agua').step(1);
		group_terrain.add(params, 'puente_pos', 0.1, 0.9).name('Posicion del puente').step(0.1);

		var group_puente = gui.addFolder('Puente');
		group_puente.add(params, 'puente_ph2', 0.0, 8.0).name('Elevación de la carretera').step(0.1);
		group_puente.add(params, 'puente_ph3', 10.0, 50.0).name('Altura de las torres').step(1.0);
		group_puente.add(params, 'puente_num_torres', 2.0, 6.0).name('Cantidad de torres').step(1.0);
		group_puente.add(params, 'puente_largo', 50.0, 500.0).name('Largo del puente').step(10.0);
		group_puente.add(params, 'puente_cur', 0.2, 0.8).name('Curvatura de la carretera').step(0.05);
		group_puente.add(params, 'puente_sep', 1.0, 3.0).name('Separacion de los tirantes').step(0.2);
		group_puente.add(params, 'puente_ancho', 8.0, 10.0).name('Ancho del puente').step(0.5);
		group_puente.add(params, 'puente_nivel').name('Nivelar altura máxima?');
		
		var group1 = group_puente.addFolder('Torre');
		group1.add(params, 'ancho_corte', 0.1, 0.9).name('Ancho corte').step(0.05);
		group1.add(params, 'prof_corte', 0.1, 1.0).name('Prof. corte').step(0.05);
		group1.add(params, 'reduccion', 0.5, 1.0).name('Reduccion').step(0.05);
		
		var group2 = gui.addFolder('General');
		group2.add(params, 'debug_mode').name('Debug');
		group2.add(params, 'line_strip').name('LINE_STRIP?');
		group2.add(params, 'reiniciar').name("Reiniciar");

	}
		
	function main() {
		initWebGL();
		if (gl) {
			setupWebGL();
			initShaders();
			setupGUI();
			loadHandler();
			loadScene();
			requestAnimationFrame(drawScene);
			
		} else {
			console.log("Parece que no hay soporte WebGL");
			alert("Error: no hay soporte WebGL.");
		}		
	}
	
	</script>
	
</head>

<!-- El cuerpo con el canvas definido -->
<body onload="main()" id="my_body">
	<center>
		<!--<h1> Esto es una prueba </h1>-->
		<canvas id="my_canvas" width="1280" height="768"></canvas>
	</center>
	
</body>


</html>
