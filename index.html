<html>

<head lang="en">
	<meta charset="UTF-8">
	<title>Prueba de sg</title>
	
	<style>
		body{ background-color: #00E676; }
		canvas{ background-color: #C51162; }
		textarea{ background-color: black; foreground-color: white;}
	</style>
	
	<script type="text/javascript" src="gl-matrix.js"></script>
	<script type="text/javascript" src="dat.gui.js"></script>
	<script type="text/javascript" src="grid.js"></script>
	<script type="text/javascript" src="scene.js"></script>
	<script type="text/javascript" src="surfaces.js"></script>
	<script type="text/javascript" src="curves.js"></script>
	<script type="text/javascript" src="terna.js"></script>
	
	<!-- Shader de vértices sin texturas -->
	<script id="shader-vs" type="x-shader/x-vertex">
		// Atributos del vértice
		attribute vec3 aVertexPosition;
		attribute vec3 aVertexNormal;
		attribute vec3 aVertexColor;
		
		// Matrices de Vista, Modelo, Proyección y Normales
		uniform mat4 uVMatrix;
		uniform mat4 uMMatrix;
		uniform mat4 uPMatrix;
		uniform mat3 uNMatrix;
		
		// Decide si se usa o no la iluminación
		uniform bool uUseLighting;
		
		// Parámetros de iluminación
		uniform vec3 uAmbientColor;
		uniform vec3 uLightPosition;
		uniform vec3 uDirectionalColor;				
		varying highp vec4 vColor;
		varying vec3 vVertexColor;
		varying vec3 vLightWeighting;
		
		void main(void) {
			// Consigo la posición proyectada del punto multiplicando por todas las matrices.
			vec4 model_view_pos = uVMatrix * uMMatrix * vec4(aVertexPosition, 1.0);
			gl_Position = uPMatrix * model_view_pos;
			
			// El color a utilizar es el mismo del vértice (no hay texturas).
			vVertexColor = aVertexColor;
			
			// ILUMINACIÓN
			
			// Calculo la posición relativa de la fuente de luz dirigida respecto al vértice y normalizo
			
			vec3 light_dir = uLightPosition - vec3(model_view_pos);
			normalize(light_dir);
			if (!uUseLighting) {
				vLightWeighting = vec3(1.0, 1.0, 1.0);
			} else {
				vec3 transformedNormal = normalize(uNMatrix * aVertexNormal);
				float directionalLightWeighting = max(dot(transformedNormal, light_dir), 0.0);
				vLightWeighting = uAmbientColor + uDirectionalColor * directionalLightWeighting;
			}
		}
	
	</script>
	
	
	<!-- Shader de fragmentos sin texturas -->
	<script id="shader-fs" type="x-shader/x-fragment">
		precision mediump float;

		varying vec3 vVertexColor;
		varying vec3 vLightWeighting;

		uniform sampler2D uSampler;

		void main(void) {
			gl_FragColor = vec4(vVertexColor.rgb * vLightWeighting, 1.0);
		}
	</script>
	
	
	
	<!-- El script posta -->
	<script>
	
	var canvas = null;
	var gl = null;
	var glShaderColor;
	
	var params = {
		periodoC1:1.0,
		reiniciar:loadScene
	};
	
	
	 // SHADERS FUNCTION
	function getShader(gl, id) {
		var shaderScript, src, currentChild, shader;

		// Obtenemos el elemento <script> que contiene el código fuente del shader.
		shaderScript = document.getElementById(id);
		if (!shaderScript) {
			return null;
		}

		// Extraemos el contenido de texto del <script>.
		src = "";
		currentChild = shaderScript.firstChild;
		while(currentChild) {
			if (currentChild.nodeType == currentChild.TEXT_NODE) {
				src += currentChild.textContent;
			}
			currentChild = currentChild.nextSibling;
		}

		// Creamos un shader WebGL según el atributo type del <script>.
		if (shaderScript.type == "x-shader/x-fragment") {
			shader = gl.createShader(gl.FRAGMENT_SHADER);
		} else if (shaderScript.type == "x-shader/x-vertex") {
			shader = gl.createShader(gl.VERTEX_SHADER);
		} else {
			return null;
		}

		// Le decimos a WebGL que vamos a usar el texto como fuente para el shader.
		gl.shaderSource(shader, src);

		// Compilamos el shader.
		gl.compileShader(shader);  
		  
		// Chequeamos y reportamos si hubo algún error.
		if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {  
			alert("Error compilando los shaders: " + 
			gl.getShaderInfoLog(shader));  
			return null;  
		}
		  
		return shader;
	}
	
	// Carga el canvas y obtiene el rendering context
	function initWebGL() {
		canvas = document.getElementById("my_canvas");
		try {
			gl = canvas.getContext("webgl");
		} catch (e) {
			console.log("Error cargando WebGL");
		}
	}
	
	// Configuración del canvas
	function setupWebGL() {
		gl.clearColor(0.77, 0.07, 0.243, 1.0);
		
		// Habilitando y configurando cómo tratar el buffer de profundidad
		gl.enable(gl.DEPTH_TEST);
		gl.depthFunc(gl.LEQUAL);
		
		gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);
		
		// Configurando el viewport
		gl.viewport(0, 0, canvas.width, canvas.height);
		
	}
			
	function initShaders() {
		// Creo el programa con los shaders para objetos coloreados
		var fragmentShader = getShader(gl, "shader-fs");
		var vertexShader = getShader(gl, "shader-vs");
		
		glShaderColor = gl.createProgram();
		
		gl.attachShader(glShaderColor, vertexShader);
		gl.attachShader(glShaderColor, fragmentShader);
		
		gl.linkProgram(glShaderColor);
		
		if (!gl.getProgramParameter(glShaderColor, gl.LINK_STATUS)) {
			alert("Error cargando los shaders.  " + gl.getProgramInfoLog(glShaderColor));
			return null;
		}
		
		// Punteros a los atributos del shader
		glShaderColor.aVertexPosition = gl.getAttribLocation(glShaderColor, "aVertexPosition");
		gl.enableVertexAttribArray(glShaderColor.aVertexPosition);
		
		glShaderColor.aVertexNormal = gl.getAttribLocation(glShaderColor, "aVertexNormal");
		gl.enableVertexAttribArray(glShaderColor.aVertexNormal);
		
		glShaderColor.aVertexColor = gl.getAttribLocation(glShaderColor, "aVertexColor");
		gl.enableVertexAttribArray(glShaderColor.aVertexColor);
		
		// Punteros a las matrices y parámetros uniform
		glShaderColor.uVMatrix = gl.getUniformLocation(glShaderColor, "uVMatrix");
		glShaderColor.uMMatrix = gl.getUniformLocation(glShaderColor, "uMMatrix");
		glShaderColor.uPMatrix = gl.getUniformLocation(glShaderColor, "uPMatrix");
		glShaderColor.uNMatrix = gl.getUniformLocation(glShaderColor, "uNMatrix");
			// Parámetros de iluminación
		glShaderColor.uUseLighting = gl.getUniformLocation(glShaderColor, "uUseLighting");
		glShaderColor.uAmbientColor = gl.getUniformLocation(glShaderColor, "uAmbientColor");
		glShaderColor.uLightPosition = gl.getUniformLocation(glShaderColor, "uLightPosition");
		glShaderColor.uDirectionalColor = gl.getUniformLocation(glShaderColor, "uDirectionalColor");
				
		gl.useProgram(glShaderColor);
	}
	
	////////
	var time = 0;
	var pMatrix = mat4.create();
	var my_scene = null;
	function drawScene() {
		// Esto garantiza que se llame continuamente al drawScene
		requestAnimationFrame(drawScene);
		
		gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
		
		// Preparamos una matriz de perspectiva. (FOV, aspectRatio, z_front y z_back).
		mat4.perspective(pMatrix, 45, 1280.0/768.0, 0.1, 100.0);
		gl.uniformMatrix4fv(glShaderColor.uPMatrix, false, pMatrix);
		
		my_scene.draw(time);
		time += 0.01;
	}
	
		
	function loadScene() {
		my_scene = new Scene();
		my_scene.init();
	}
	
	
	function setupGUI() {
	
		var gui = new dat.GUI();
		
		var group1 = gui.addFolder('Curva1');
		group1.add(params, 'periodoC1', 0.0, 8.0).name('Período').step(0.1);
		group1.add(params, 'reiniciar').name("Reiniciar");

	}
		
	function main() {
		initWebGL();
		if (gl) {
			setupWebGL();
			initShaders();
			setupGUI();
			
			loadScene();
			requestAnimationFrame(drawScene);
		} else {
			console.log("Parece que no hay soporte WebGL");
			alert("Error: no hay soporte WebGL.");
		}		
	}
	
	
	
	
	</script>

	
</head>


<!-- El cuerpo con el canvas definido -->
<body onload="main()">
	<center>
		<h1> Esto es una prueba </h1>
		<canvas id="my_canvas" width="1280" height="768"></canvas>
	</center>
</body>


</html>